<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>LamPI Architecture</title>
</head>

<body>

<h1>LamPI Architecture Intro</h1>
<p>This chapter describes some design and architecture considerations for LamPI. It is meant to provide background information on why the components and their setup are chosen the way they are, and at the same time will allow you to judge if you can live with that setup or whether you are convinced that you can do better yourself. </p>
<p>Please tell me if you consider certain aspects a major flaw, and I might re-design those parts. Also, if you like to partitipate in the project and rewrite some new parts of the code, please tell me. This chapter contains the following subjects (for easy navigation):</p>
<ul>
  <li><a href="#maincomponents">Overview of the main components and their relation.</a></li>
  <li><a href="#messageformats">Message Formats (layout of messages exchanged between LamPI components)</a></li>
  <li><a href="#lampidaemon">Architecture of the LamPI-daemon</a></li>
  <li><a href="#transceiver">Architecture of the LamPI transceiver part</a><br>
  </li>
  <li><a href="#lampigui">The webbrowser front-end client in Javascript/jQuery</a></li>
  <li><a href="#android">The Android client</a></li>
  <li>Z-Wave device support (how to control Z-Wave devices)</li>
</ul>
<p>LamPI started as an alternative controller to the ICS-1000 controller of klikaanklikuit.nl (150 EURO), but today it offers support for other brands as well as well support for sensors and even 868MHz Z-Wave devices.</p>
<h1><a name="maincomponents"></a>Main Components and Relations</h1>
<p>LamPI consists of a few major components as outlined in the pisture below (picture needs some updating). Starting with release 1.7 all communication between the front-end and the controlling daemon takes place over websockets. Of course, when you work with the ICS-1000 this will be an exception.</p>
<p><img src="architecture.gif" width="960" height="720"></p>
<p>There are advantages and disadvantages wrt to the approach chosen for the communication between frontend and LamPI-daemon backend.</p>
<p>The disadvantage is that with the old plain socket communication and supporting ajax PHP scripts such as backend_rasp.php all looked much easier and developer is in control. Only you think you are, as most of the ajax calls are asynchronous in nature, and the backend PHP scripts run only once so information that is not directy available from the LamPI-daemon will not be received and results in a time-out.</p>
<p>Webserver transmission is rather simple, once the socket is open you're good to go. Incoming messages are more complicated, they arrive asynchronously to the LamPI-x.y.js client and so we must make sure that these messages are delivered to the correct handler of the program. Also, it is good to define a standard message format between GUI &lt;-&gt; LamPI-daemon &lt;-&gt; Transmitter/Receiver/Sensors.</p>
<p>As good example is what we do with incoming startus changes for devices in the program.</p>
<ul>
  <li>If we receive status change for a device which is in our current room on screen, we want to update the switch or slider on the screen to reflect the change in value.</li>
  <li>If the update is for a device not on screen, someone should have updated the value in the database and working buffers so that if we switch to that device we see the current (just changed) value.</li>
  <li>Stuff that we cannot do anything with needs to be discarded (or stored for later use).</li>
</ul>
<p>&nbsp;</p>
<h1><a name="messageformats"></a>Message Formats</h1>
<p>Between the parts of the LamPI system, several components exchange messages to inform the other of device changes, temperature values, initializations etc etc. This call for a standard message format that we can use between all components. This section describes the messages that are exchanged between the LamPI components. In the middle of all communication is the LamPI-daemon, therefore we will discuss the messaging seen from the LamPI-daemon as it communicates with GUI's, sensors and other devices/programs.</p>
<p>The general message format in (semi-) PHP language is constructed as follows:</p>
<p><code>$message = array (<br>
  'tcnt' =&gt; $tcnt.&quot;&quot;,<br>
  'type' =&gt; 'raw',<br>
  'action' =&gt; &quot;&lt;msg action&gt;&quot;,<br>
'field-1' =&gt; &quot;&lt;field-1 string&gt;&quot;,</code></p>
<p>...</p>
<p><code>'field-n' =&gt; &quot;&lt;field-n string&gt;&quot;<br>
  );</code></p>
<p>&lt;msg action&gt; is of type string and can be on of the following: </p>
<ol>
  <li><code>&quot;ack&quot;,</code></li>
  <li><code>&quot;ping&quot;,</code></li>
  <li><code>&quot;gui&quot;,</code></li>
  <li><code>&quot;handset&quot;,</code></li>
  <li><code>&quot;weather&quot;,</code></li>
  <li><code>&quot;energy&quot;,</code></li>
  <li><code>&quot;sensor&quot;,</code></li>
  <li><code>&quot;load-database&quot;,</code></li>
  <li><code>&quot;login&quot;,</code></li>
  <li><code>&quot;console&quot;</code></li>
</ol>
<p>In the sections below the messages are explained in more detail.</p>
<h2>1. ack</h2>
<p>Acknowledge message, telling connected clients that the LamPI-daemon as received its message OK.</p>
<h2>2. ping</h2>
<p>The LamPI-daemon received PING messages from some of its connected clients to tell that they are still alive. This messaging might disappear in later releases of the software as during normal operations it does not add value. It does however for maintenance and debugging purposes.</p>
<h2>3. gui</h2>
<p>Let's start with the messages between the GUI and the LamPI daemon. The GUI connects to the LamPI-daemon either through Ajax calls (Old way) or over a websocket connection. Wesbockets use the jSon message format and therefore a range of messages is used to get messages accross to the LamPI-daemon. The content of these messages are in the standard ICS-1000 message format which is a simple ASCII coding. However, since the LamPI system supports more devices than the ICS-1000 some additional messages are defined.</p>
<h2>4. handset</h2>
<p>Handsets from klikaanklikuit, Action or other handsets that are defined and recognized can send information about buttons pressed to the LamPI-daemon process.</p>
<h2>5. weather</h2>
<p>Messages received from the LamPI_receiver or any other sensor control program might contain the weather action, which will be interpreted by the LamPI_daemon and its values forwarded to the connected GUI clients.</p>
<h2>6. energy</h2>
<p>tbd</p>
<h2>7. Sensor-Daemon Message Format</h2>
<p>The second important message format is between sensors and the LamPI-daemon. Sensors connect to the LamPI-daemon through there own piec of code which will read the sensor value, open a socket connection to the daemon and send the value in a jSon encoded format.</p>
<h2>8. load_database</h2>
<p>This is the message that will reset the Mysql database and re-load the database.cfg file into the system</p>
<h2>9. login</h2>
<p>This message is used to tell the GUI that the LamPI-daemon does or does not trust the client, based on its IP address.</p>
<h2>10. console</h2>
<p>The console message is used to receive and send messages to the GUI client that contain console/management - like information about the system. Examples are: Connected clients to the LamPI-deamon, last 20 lines of the log/LamPI_daemon.log file and restarting the daemon itself.</p>
<h2>Z-wave Connect</h2>
<p>The Z-Wave messaging format is described on the separate Z-Wave page. Reason is that this is not so much a programming interface but communication takes place as a URL string that is executed by &quot;curl&quot; in the LamPI-daemon. At the moment the communication is therefore initiated by the LamPI-daemon only.</p>
<p>The Z-Way software contains Javascript library functions to build actions and initiate communication from the Razberry device but this is not implemented (yet), and therefore for example administrative functions for adding Z-Wave devices must be done using the Razberry interface on that machine itself.</p>
<p>http://&lt;raspberry_ip_address&gt;:8083</p>
<p>Then choose the traditional blue interface and then &quot;network&quot; to setup your new Z-Wave device.</p>
<p>&nbsp;</p>
<h1><a name="lampidaemon"></a>Architecture of the LamPI-daemon</h1>
<p>The LamPI-daemon is a PHP program that will accept socket connections from clients and  transceivers. It will accept device commands from the front end and send back status changes of devices (for example from timers). ON the &quot;other side&quot; it will messages from the transceiver with read sensor and handset information and may act upon those messages. LamPI-daemon will also initiate messages to the 433MHz devices based on either incoing commands from the client(s) or timers that expire for certain actions. The LamPI-daemon is implemented in PHP and is found in the exe directory (as we have to remove such a PHP function from the www directory so it cannot be called directly by a web client).</p>
<h2>Why use PHP</h2>
<p>The fact that the daemon is implemented as a PHP program has its reasons. And of course there are disadvantages but also advantages to this approach. Let me start off with some reasons why I decided to implement the daemon in PHP rather than C or C++.</p>
<ul>
  <li>PHP is present on (m)any webservers; </li>
  <li>It is much more well-known to web developers than C or C++</li>
  <li>It is a language with very many built-in functions</li>
  <li>Easy debugging</li>
</ul>
<p>Some disadvantages of not using C/C++</p>
<ul>
  <li>Speed; PHP is an interpreted language. This may sound as a serious disadvantage, but speed as in reaction time is not important as the resolution for timing is 1 minute for timing settings, and a second for timing of commands coming from clients.</li>
  <li>Linux standard for daemons is C; true in most cases, and daemons are started in services/init.d or inet in most cases. However, for a Raspberry that will in most cases be dedicated to just this task or one or two others this is not a problem.</li>
  <li>PHP does not have native websocket support. Nor does C/C++, but we're used to that. Actually, initiating socket communication is a lot simpler in PHP than C and although PHP does not yet have a websockets layer, it does have native jSon encode/decode functions which are very easy due to the flexible memory allocation in PHP.</li>
</ul>
<p>So, after some consideration I decided that building this daemon in PHP would offer me more functions, allow me to put the daemon on almost any webserver without the need of a C/C++ compiler and be much more flexible when making changes.</p>
<h2>Structure of the LamPI-daemon.php file</h2>
<p>The LamPI-daemon process is implemented in the LamPI-daemon.php file and one or two supporting files (one for configuration and one for common smaller functions). The file is split in a few important parts:</p>
<ul>
  <li>The definition of supporting functions that are called from the main program</li>
  <li>The main program initialization part for variables and reading the commandline</li>
  <li>The main Loop for the daemon with globally three stages:
    <ol>
      <li>Reading the Sockets; for incoming requests from the clients and incoming messages from sensors or handsets.</li>
      <li>Run Queue; The queue where all runnable commands (received from timers and over sockets) are in is read and if it is time, the command is popped off the queue and the command messages is forwarded to the transceiver which will send the command to the 433MHz devices in our home.</li>
      <li>Timer section. It will read the MySQL database and if there are timers that expire, it will read the scene with actions associated with that timer and after breaking down each of the device commands in that scene, these device commands are put in the run queue for the daemon</li>
    </ol>
  </li>
</ul>
<p>Note: The run queue might also consist of more complex commands such as &quot;All Off&quot; in a room. If such a complex command is encountered on the Run Queue it is replaced with the individual device &quot;OFF&quot; commands which are then each added to the Run Queue instead.</p>
<h3>Stage 1: Reading the Sockets</h3>
<p>In the first stage of the Main Loop, we read sockets and process incoming messages and reply where necessary to connected GUI clients and daemon programs (receivers). For the GUI clients we make use of websockets, which is a more secure and protected service using a 2-step connection mechanism. For the receivers (433, 1-wire etc sensors) we use a simple interface which is not based on websockets. If we receive an incoming GUI message telling us that the used changed the setting of a remote dimmer, than the message will be decoded an put in the run-queue of ready-to-run device commands. In stage 2 (below) the run queue will be handled and we will take care of messages/commands tha are ready to run.</p>
<p>The LamPI-daemon.php process will accept both websocket and normal connect requests and we will make note of the type of device connecting. This is important, as incoming messages from sensors need to be forwarded to the connect GUI clients but most likely we do NOT forward to other receivers. </p>
<p>As of release 1.9.3 the default communication protocol for sensors is UDP broadcast (SOCK_DGRAM). The advantage for using a connectionless broadcast messaging protocol outweigh the drawbacks of UDP, which is that it is less reliable and one might miss a transmission. As messages sent by sensors are mostly shorter in size than a few hundred bytes, we do not really need a connection-based protocol that is reliable. After all, we are not making a tcp service for transmitting magebytes of data, and should we miss a message than within one or two minutes the next sensor message will be transmitted.</p>
<h3>Stage 2: Reading the run queue</h3>
<p>The run queue is defined by the QUEUE class and defined in the LamPI-daemon.php file. The Queue consists of messages that are all defined in the same sort of syntax that is used by the ICS-1000 device, but extended with some new message definitions that we use for connected handsets, sensors etc.</p>
<p>A special case are the &quot;All Off&quot; scene commands. If we encounter such a command next in the queue, the scene message is replace by a room &quot;device OFF&quot; command for every device in that room. </p>
<h3>Stage 3: Reading Timers (and put ready commands in run queue)</h3>
<p>When starting this stage in the daemon loop, we start reading the database and load the timers array with the latest values in the database. This prevents us from taking actions based on database information that could already be out of date.</p>
<p>If we find a timer that is runnable, we take the scene command inside that timer and put it on the run queue. It will then be taken off the queue in the next loop of the program in stage 2.</p>
<p>&nbsp;</p>
<h1><a name="transceiver"></a>Architecture of the Transceiver parts</h1>
<p>Transceivers is not entirely the correct name for the programs in this section. But as seen from the LamPI-daemon (<a href="#lampidaemon">see next main section</a>) these are the functions interfacing with the physical 433MHz receiver and transmitter devices on the RaspberryPI. The daemon sees it as one connection with the Raspberry for both receiving handset/sensor information as well as sending device commands.</p>
<p>The transceiver functions are located in the /receiver subdirectory.</p>
<h2>Transmitters</h2>
<p>The transmitter function is the most straightforward function implemented. For every known and supported brand we compile and build and executable which is installed in the ~/exe directory. It is possible to call these functons from the commandline, but if we run the LamPI-receiver in daemon mode (-d option) the daemon will also provide transmitter functions (for requests coming in on sockets). The LamPI-receiver will call these command-line programs directly.</p>
<p>Therefore it makes sense to keep the naming of the transmitter programs standard (make no change, or if you do change the transmitter.c code as well). Also the commandline options for each of the transmitter programs are the same (makes sense too, not?). All programs must be called as follows&quot;</p>
<p><code>&gt; cd ~/.exe<br>
  &gt; ./mysender -g &lt;adress&gt; -n &lt;unit&gt; [-p &lt;pin&gt;] &quot;on&quot; | &quot;off&quot; | &quot;dimlevel&quot;
</code></p>
<p>Of course, on and off are universal commands for both switches and dimmers, dimlevel is at the moment only supported for klikaanklikuit devices.</p>
<p>the following options are supported and must be present in new transmitter programs too:</p>
<ul>
  <li>-g &lt;address&gt;</li>
  <li>-n &lt;address&gt;</li>
  <li>-p &lt;pin number&gt; ; optional: according to the  wiringPi convention</li>
</ul>
<p>The transmitter programs reside in dfferent directories: Some C++ code in the &quot;lights&quot; directory was ported from an existing Arduino library and contains support for multiple transmitters with same prototype definitions in C++. Some other code such as for Kopou, WT440H and Livolo was developed.</p>
<h2>Sniffer LamPI-receiver</h2>
<p>The way that the sniffer function works needs some explaining.</p>
<h4>lampi_interrupt  (sniffer.c)</h4>
<p>Core for this function is the handling of incoming pulses. Incoming pulses cause the pin of wiringPi library to change from low to high or vice-versa. Therefore we built an interrupt handler that is triggered by every change in the pin. As soon as an interrupt arrives, the function is executed and it does basically the following things:</p>
<ul>
  <li>Store the time (in uSecs) that the function is called. </li>
  <li>Compare the time with the time of the previous interrupt call and the difference is our pulse time. </li>
  <li>The pulse time is stored in the global pulse-array, which is sufficiently large to store pulses for some time</li>
  <li>The global variable p_index is a pointer that keeps track of the position of the last pulse in the array</li>
  <li>Note: The array is made a circular buffer. As soon as p_index becomes larger than the MAX_DATA_SIZE it is make 0 again.</li>
  <li>where the interrupt function is writing and the main program loop is reading (a little later). The global reader pointer is r_index.</li>
  <li>If the write pointer p_index risks to overwrite the r_index position (so we write far more than we read) we set a special variable stop_ints that will stop further writing to the array until we read up in the pulse_array buffer</li>
</ul>
<h4>The main reader loop  (sniffer.c)</h4>
<p>&nbsp;</p>
<h4>transmitter (transmitter.c)</h4>
<p>Without the -d option to the commandline, the sniffer program will not be configured to interface with the various transmitters. But with the -d options specified, the sniffer executable (or if you run make install it is called ~/exe/LamPI-receiver) will act as a daemon listening to port 5000 on a socket TCP connection. It will write all received handset and sensor codes to the socket, but more importantly for this discussion, it will also listen to incoming commands over the socket and than call the corresponding transmitter program.</p>
<h3>Message format</h3>
<p>The message format that is exchanged between the LamPI-daemon and the LamPI-receiver process (2-way) is described in more detail above.</p>
<p>&nbsp;</p>
<h1><a name="lampigui"></a>The LamPI.js GUI</h1>
<p>The LamPI-x.y.js file contains (most of) the front end of the LamPI application. It contains Javascript code in combination with a lot of jQuery functions that will shield the complex Ajax functions from the user and expands the code with useful widgets and buttons.</p>
<p>The LamPI Javascript program with with regular browser programs in which it will make use of jQuery UI function. Alternatively, when using the android client, the program will make use of jQuery Mobile libraries that are optimized for use in mobile devices such as Android clients.</p>
<h1><a name="android"></a>Android Clients</h1>
<p>Android code is in beta, but as you can see in the LamPI-x.y.js file, significant parts are already there and the code is usable. </p>
<ul>
  <li>Need to explain what changes ned to be made to index.html in order for the LamPI-x.y.js file to correctly work in jQuery mobile mode and select the right css skin etc.</li>
  <li>Need to write-up how to build a PhoneGap application for Android</li>
</ul>
<p>&nbsp;</p>
</body>
</html>
